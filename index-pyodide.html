<html>
<head>
  <meta charset="utf-8">
  <title>Plotting workload distribution</title>
  <script type="text/javascript">
    // set the pyodide files URL (packages.json, pyodide.asm.data etc)
    window.languagePluginUrl = 'https://cdn.jsdelivr.net/pyodide/v0.15.0/full/';
  </script>
  <script type="text/javascript" src="https://cdn.jsdelivr.net/pyodide/v0.15.0/full/pyodide.js"></script>
  <!-- Load plotly.js into the DOM -->
  <script src='https://cdn.plot.ly/plotly-latest.min.js'></script>
</head>
<body>
  <h1>Plots of the workload distribution</h1>
  <div>
    <p>Generates the plots of the workload distributions of a special kind of queueing system.</p>
    <p>This queueing system has <b>c</b> servers and an arrival stream of customers of Poisson type with homogeneous parameter <b>&lambda;</b>.</p>
    <p>Whenever a customer arrives it is tagged as <i>customer of type <b>1</b></i> on arrival the workload is below the threshold <b>k</b>, 
      otherwise it is tagged as <i>customer of type <b>2</b></i>.</p>
    <p>All customers have a service time exponential distributed, 
      type 1 customers with parameter <b>&mu;<sub>1</sub></b>
      and type 2 customers with parameter <b>&mu;<sub>2</sub></b>.
  </div>

  <div id="form">
    <h2>Parameters:</h2>
      <label for="interval_c" style="display: inline-block; width: 20px;">c</label>
      <input type="text" id="interval_c" name="interval_c" value="" readonly disabled><br><br>
      <label for="param_lambda" style="display: inline-block; width: 20px;">&lambda;</label>
      <input type="text" name="param_lambda" id="param_lambda" value="2"><br>
      <label for="param_mu1" style="display: inline-block; width: 20px;">&mu;<sub>1</sub></label>
      <input type="text" name="param_mu1" id="param_mu1" value="0.75"><br>
      <label for="param_mu2" style="display: inline-block; width: 20px;">&mu;<sub>2</sub></label>
      <input type="text" name="param_mu2" id="param_mu2" value="1.12"><br>
      <label for="param_k" style="display: inline-block; width: 20px;">k</label>
      <input type="text" name="param_k" id="param_k" value="0.45"><br><br>
      <input name="update" id="update" type="submit" value="Draw" onclick="updateGraph();"disabled/><br><br>
  </div>
  <div id="root"></div>
  <div style="position: absolute; bottom: 0px;"><a href="index-mathjs.html">Mathjs version</a></div>

  <script type="text/javascript">
    pythonImports = `
      import js
      import numpy as np 
      from numpy import identity, sum
      from numpy import transpose as tr
      from numpy import diagflat as to_diag
      from numpy.linalg import inv
    `

    pythonDefinitions = `
      def null_space(A, rcond=None):
        # taken from scipy.linalg.null_space
        u, s, vh = np.linalg.svd(A, full_matrices=True)
        M, N = u.shape[0], vh.shape[1]
        if rcond is None:
            rcond = np.finfo(s.dtype).eps * max(M, N)
        tol = np.amax(s) * rcond
        num = np.sum(s > tol, dtype=int)
        Q = vh[num:,:].T.conj()
        return Q

      def expm(A, n_max=1024, prec=1e-08):
        if len(A.shape) != 2 or A.shape[0] != A.shape[1]:
            raise ValueError('expected a square matrix')
        res = np.identity(A.shape[0])
        M = 0 * res 
        n = 0
        while np.max(np.abs(res))>prec and n<n_max:
            M = M + res
            n = n + 1
            res = res @ A / n
        if (n==n_max):
            raise Warning("reached maximum number of iterations")
        return M
    `

    pythonWorkloadFunction = `
      def workload(c=2, Î»=1, Î¼1=0.45, Î¼2=0.55, k=0.1):

        # Definitions
        Î¼ = lambda i, j : i * Î¼1 + j * Î¼2
        Î”0 = np.diag([Î¼(i,c-1-i) for i in range(c)])
        Î”1 = np.diag([Î¼(i+1,c-1-i) for i in range(c)])
        Î”2 = np.diag([Î¼(i,c-i) for i in range(c)])

        Î¼vec = lambda n : [Î¼(i,n-i) for i in range(n+1)]
        hÎ” = lambda n : np.diag(Î¼vec(n))
        hB = lambda n : np.array([[(i==j)*(n+1-i)*Î¼2+(i==j+1)*i*Î¼1 for j in range(n+1)] for i in range(n+2)])
        hI = lambda n : np.array([[(i+1==j)*1 for j in range(n+1)] for i in range(n)])

        Q1 = lambda x : expm(-x*Î”1)
        Q2 = lambda x : expm(-x*Î”2)
        B1 = np.array([[(i==j)*(i+1)*Î¼1+(i+1==j)*(c-1-i)*Î¼2 for j in range(c)] for i in range(c)])
        B2 = np.array([[(i==j)*(c-i)*Î¼2+(i-1==j)*i*Î¼1 for j in range(c)] for i in range(c)])

        tÎ”1 = np.linalg.inv(B1) @ Î”1 @ B1
        tÎ”2 = np.linalg.inv(B2) @ Î”2 @ B2
        tQ1 = lambda x : inv(B1) @ Q1(x) @ B1
        tQ2 = lambda x : inv(B2) @ Q2(x) @ B2

        # Solving homogeneous equations
        D1 = lambda x : pow(x,2) * identity(c) - x * (Î» * identity(c) - tÎ”1) + Î» * (B1 - tÎ”1)
        D2 = lambda x : pow(x,2) * identity(c) - x * (Î» * identity(c) - tÎ”2) + Î» * (B2 - tÎ”2)
        eigenvector = lambda x : tr(null_space(tr(x)))

        Î¸1P = [(Î»-Î¼(i+1,c-1-i)+np.sqrt(pow(Î»-Î¼(i+1,c-1-i),2)+4*Î»*Î¼(0,c-1-i)))/2 for i in range(c)]
        Î¸1N = [(Î»-Î¼(i+1,c-1-i)-np.sqrt(pow(Î»-Î¼(i+1,c-1-i),2)+4*Î»*Î¼(0,c-1-i)))/2 for i in range(c)]
        Î¸2P = [(Î»-Î¼(i,c-i)+np.sqrt(pow(Î»-Î¼(i,c-i),2)+4*Î»*Î¼(i,0)))/2 for i in range(c)]
        Î¸2N = [(Î»-Î¼(i,c-i)-np.sqrt(pow(Î»-Î¼(i,c-i),2)+4*Î»*Î¼(i,0)))/2 for i in range(c)]

        É¸1P = np.concatenate([eigenvector(D1(Î¸1P[i])) for i in range(c)])
        É¸1N = np.concatenate([eigenvector(D1(Î¸1N[i])) for i in range(c)])
        É¸2P = np.concatenate([eigenvector(D2(Î¸2P[i])) for i in range(c)])
        É¸2N = np.concatenate([eigenvector(D2(Î¸2N[i])) for i in range(c)])

        U1P = inv(É¸1P) @ to_diag(Î¸1P) @ É¸1P
        U1N = inv(É¸1N) @ to_diag(Î¸1N) @ É¸1N
        U2P = inv(É¸2P) @ to_diag(Î¸2P) @ É¸2P
        U2N = inv(É¸2N) @ to_diag(Î¸2N) @ É¸2N

        # Solving homogeneous equations
        vÎ·1 = eigenvector(D1(0))
        MÎ·1 =  Î» * (B1 - tÎ”1) - to_diag(vÎ·1)
        M0 = inv(MÎ·1)
        vÎ·2 = eigenvector(D2(0))
        MÎ·2 =  Î» * (B2 - tÎ”2) - to_diag(vÎ·2)
        M1 = inv(MÎ·2)
        M2 = inv((Î”1[-1,-1] + Î») * (Î”1[-1,-1] * identity(c) - tÎ”2) + Î» * B2)

        H1 = inv(U1P - U1N) @ (expm(k * U1P) - expm(k * U1N))
        H2 = M0 @ (identity(c) - expm(k* U1N) + U1N @ H1)
        H3 = H1 + tÎ”1 @ H2
        H4 = - Î» * B1 @ H2

        H5 = inv(U1P - U1N) @ (U1P @ expm(k * U1P) - U1N @ expm(k * U1N))
        H6 = M0 @ (U1N @ expm(k * U1N) - U1N @ H5)
        H7 = H5 - tÎ”1 @ H6
        H8 = Î» * B1 @ H6

        H9 = (tÎ”1 - tÎ”2) @ M2 @ U2N + tÎ”1 @ (tÎ”1 - tÎ”2) @ M2 
        H10 = U2N - Î» * (identity(c) - B2 @ inv(tÎ”2)) @ H9
        H11 = M1 @ U2N + inv(tÎ”2) @ H9
        H12 = H10 + Î» * (B1 @ inv(tÎ”1) @ tÎ”2 - B2) @ H11
        H13 = tÎ”2 @ H11
        H14 = Î» * B1 @ inv(tÎ”1) @ tÎ”2 @ H11

        H15 = inv(H7 - H7 @ H9 - H3 @ H12 + H13)
        H16 = (H14 + H4 @ H12 - H8 + H8 @ H9) @ H15

        H17 = tÎ”2 @ M1 - Î» * H3 @ (B1 @ inv(tÎ”1) @ tÎ”2 - B2) @ M1
        H18 = Î» * B1 @ inv(tÎ”1) @ tÎ”2 @ M1 + Î» * H4 @ (B1 @ inv(tÎ”1) @ tÎ”2 - B2) @ M1
        H19 = identity(c) - U2N @ H15 @ H17
        H20 = H16 @ H17 - H18

        # Solving the final system of equations
        def hC(n):
            if (n==0):
                return hB(0) / Î»
            if (n<c-1):
                return hB(n) @ inv(Î» * (identity(n+1) - hC(n-1) @ hI(n))+ hÎ”(n) )
            if (n==c-1):
                return - U2N @ H15 @ inv(Î» * (identity(c) - hC(c-2) @ hI(c-1)) + hÎ”(c-1)  - H16)
            return -1

        def hH(n):
            if (n==c-1):
                return hC(c-1)
            if (n<c-1):
                return hH(n+1) @ hC(n)
            return -1

        bcsol = 1/(sum(vÎ·2 @ (H19 + hH(c-1) @ H20)) + sum([sum(vÎ·2 @ hH(n)) for n in range(c)]))
        Î´sol = lambda n : bcsol * vÎ·2 @ hH(n)


        # Constructing the workload function
        vf0sol = Î´sol(c-1) @ H16 - bcsol * vÎ·2 @ U2N @ H15
        vfksol = vf0sol @ H7 + Î´sol(c-1) @ H8
        vFksol = vf0sol @ H3 + Î´sol(c-1) @ H4

        ð›¼0sol = vf0sol @ tÎ”1 - Î» * Î´sol(c-1) @ B1
        ð›¼1sol = ð›¼0sol @ inv(tÎ”1) @ tÎ”2 - Î» * vFksol @ (B1 @ inv(tÎ”1) @ tÎ”2 - B2)
        ð›¼2sol = ð›¼1sol @ inv(tÎ”2) - vfksol +  Î» * vFksol @ (identity(c) - B2 @ inv(tÎ”2))

        F2solInf = bcsol * vÎ·2 @ H19 + Î´sol(c-1) @ H20
        Wpos = 1 - sum(F2solInf)

        F1sol = lambda x : (vf0sol + ð›¼0sol @ M0 @ U1N) @ inv(U1P - U1N) @ (expm(x*U1P) - expm(x*U1N)) + ð›¼0sol @ M0 @ (identity(c) - expm(x*U1N))
        F2sol = lambda x : vFksol @ expm((x-k)*U2N) + (bcsol * vÎ·2 + ð›¼1sol @ M1) @ (identity(c) - expm((x-k)*U2N)) - ð›¼2sol @ ((tÎ”1-tÎ”2) @ M2 @ expm((x-k)*U2N) - tQ1(x-k) @ (tÎ”1-tÎ”2) @ M2)
        Fsol = lambda x :  F1sol(x) if (x<k) else F2sol(x)
        Wsol = lambda x :  Wpos + sum(Fsol(x))

        # returning the workload function 
        return Wsol
    `
    var cmin = 2;
    var cspread = 3;
    document.getElementById("interval_c").value = "from " + cmin + " to " + (cmin+cspread);
    var ready= false;
    var Lambda, mu1, mu2, k;

     var el = document.getElementById("update");

    function chechData() {
      Lambda = parseFloat(document.getElementById("param_lambda").value)
      mu1 = parseFloat(document.getElementById("param_mu1").value)
      mu2 = parseFloat(document.getElementById("param_mu2").value)
      k = parseFloat(document.getElementById("param_k").value)
      for (var c = 0; c < cspread; c++) {
        if (Lambda == (cmin+c)*mu1) return false
      }
      return (Lambda>0 && mu1>0 && mu2*cmin>Lambda && k>0)
    }

    pythonCode = ` 
      Î»=js.Lambda; Î¼1=js.mu1; Î¼2=js.mu2; k=js.k; Ï=Î»/(2*Î¼2)
      crange = range(js.cmin, js.cmin + js.cspread)
      xpoints = np.linspace(start=0, stop=20*k, num=250)
      ypoints = []
      for c in crange:
          wfun = workload(c, Î», Î¼1, Î¼2, k)
          ypoints.append([wfun(x) for x in xpoints])
    `

    languagePluginLoader.then(() => {
      return pyodide.loadPackage(['numpy'])
    }).then(() => {
        pyodide.runPython(pythonImports);
        pyodide.runPython(pythonDefinitions);
        pyodide.runPython(pythonWorkloadFunction);
        ready = true
        document.getElementById("update").disabled = false;
    })

    async function updateGraph() {
      if (!ready) return false;
      if (!chechData()) return false;
      el.disabled = true;
      el.value = 'computing...';
      await new Promise(r => setTimeout(r, 50));
      pyodide.runPython(pythonCode);
      var data = []
      for (var c = 0; c < cspread; c++) {
        var trace = {
          name: 'c = ' + (c+cmin),
          x: pyodide.globals.xpoints,
          y: pyodide.globals.ypoints[c],
          type: 'scatter'
        }
        data.push(trace)
      }
      Plotly.newPlot('root', data);
      el.value = "Update";
      el.disabled = false;
    }
  </script>
</body>
</html>