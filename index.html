<html>
<head>
  <meta charset="utf-8">
</head>
<body>
  <script type="text/javascript">
      // set the pyodide files URL (packages.json, pyodide.asm.data etc)
      window.languagePluginUrl = 'https://cdn.jsdelivr.net/pyodide/v0.15.0/full/';
  </script>
  <script type="text/javascript" src="https://cdn.jsdelivr.net/pyodide/v0.15.0/full/pyodide.js"></script>
  <script type="text/javascript">
    pythonImports = `
      import numpy as np 
      from numpy import identity, sum
      from numpy import transpose as tr
      from numpy import diagflat as to_diag
      from numpy.linalg import inv
    `

    pythonDefinitions = `
      def null_space(A, rcond=None):
        # taken from scipy.linalg.null_space
        u, s, vh = np.linalg.svd(A, full_matrices=True)
        M, N = u.shape[0], vh.shape[1]
        if rcond is None:
            rcond = np.finfo(s.dtype).eps * max(M, N)
        tol = np.amax(s) * rcond
        num = np.sum(s > tol, dtype=int)
        Q = vh[num:,:].T.conj()
        return Q

      def expm(A, n_max=255, prec=1e-08):
        if len(A.shape) != 2 or A.shape[0] != A.shape[1]:
            raise ValueError('expected a square matrix')
        res = np.identity(A.shape[0])
        M = 0 * res 
        n = 0
        while np.max(np.abs(res))>prec and n<n_max:
            M = M + res
            n = n + 1
            res = res @ A / n
        if (n==n_max):
            raise Warning("reached maximum number of iterations")
        return M
    `

    pythonWorkloadFunction = `
      def workload(c=2, Î»=1, Î¼1=0.45, Î¼2=0.55, k=0.1):

        # Definitions
        Î¼ = lambda i, j : i * Î¼1 + j * Î¼2
        Î”0 = np.diag([Î¼(i,c-1-i) for i in range(c)])
        Î”1 = np.diag([Î¼(i+1,c-1-i) for i in range(c)])
        Î”2 = np.diag([Î¼(i,c-i) for i in range(c)])

        Î¼vec = lambda n : [Î¼(i,n-i) for i in range(n+1)]
        hÎ” = lambda n : np.diag(Î¼vec(n))
        hB = lambda n : np.array([[(i==j)*(n+1-i)*Î¼2+(i==j+1)*i*Î¼1 for j in range(n+1)] for i in range(n+2)])
        hI = lambda n : np.array([[(i+1==j)*1 for j in range(n+1)] for i in range(n)])

        Q1 = lambda x : expm(-x*Î”1)
        Q2 = lambda x : expm(-x*Î”2)
        B1 = np.array([[(i==j)*(i+1)*Î¼1+(i+1==j)*(c-1-i)*Î¼2 for j in range(c)] for i in range(c)])
        B2 = np.array([[(i==j)*(c-i)*Î¼2+(i-1==j)*i*Î¼1 for j in range(c)] for i in range(c)])

        tÎ”1 = np.linalg.inv(B1) @ Î”1 @ B1
        tÎ”2 = np.linalg.inv(B2) @ Î”2 @ B2
        tQ1 = lambda x : inv(B1) @ Q1(x) @ B1
        tQ2 = lambda x : inv(B2) @ Q2(x) @ B2

        # Solving homogeneous equations
        D1 = lambda x : pow(x,2) * identity(c) - x * (Î» * identity(c) - tÎ”1) + Î» * (B1 - tÎ”1)
        D2 = lambda x : pow(x,2) * identity(c) - x * (Î» * identity(c) - tÎ”2) + Î» * (B2 - tÎ”2)
        eigenvector = lambda x : tr(null_space(tr(x)))

        Î¸1P = [(Î»-Î¼(i+1,c-1-i)+np.sqrt(pow(Î»-Î¼(i+1,c-1-i),2)+4*Î»*Î¼(0,c-1-i)))/2 for i in range(c)]
        Î¸1N = [(Î»-Î¼(i+1,c-1-i)-np.sqrt(pow(Î»-Î¼(i+1,c-1-i),2)+4*Î»*Î¼(0,c-1-i)))/2 for i in range(c)]
        Î¸2P = [(Î»-Î¼(i,c-i)+np.sqrt(pow(Î»-Î¼(i,c-i),2)+4*Î»*Î¼(i,0)))/2 for i in range(c)]
        Î¸2N = [(Î»-Î¼(i,c-i)-np.sqrt(pow(Î»-Î¼(i,c-i),2)+4*Î»*Î¼(i,0)))/2 for i in range(c)]

        É¸1P = np.concatenate([eigenvector(D1(Î¸1P[i])) for i in range(c)])
        É¸1N = np.concatenate([eigenvector(D1(Î¸1N[i])) for i in range(c)])
        É¸2P = np.concatenate([eigenvector(D2(Î¸2P[i])) for i in range(c)])
        É¸2N = np.concatenate([eigenvector(D2(Î¸2N[i])) for i in range(c)])

        U1P = inv(É¸1P) @ to_diag(Î¸1P) @ É¸1P
        U1N = inv(É¸1N) @ to_diag(Î¸1N) @ É¸1N
        U2P = inv(É¸2P) @ to_diag(Î¸2P) @ É¸2P
        U2N = inv(É¸2N) @ to_diag(Î¸2N) @ É¸2N

        # Solving homogeneous equations
        vÎ·1 = eigenvector(D1(0))
        MÎ·1 =  Î» * (B1 - tÎ”1) - to_diag(vÎ·1)
        M0 = inv(MÎ·1)
        vÎ·2 = eigenvector(D2(0))
        MÎ·2 =  Î» * (B2 - tÎ”2) - to_diag(vÎ·2)
        M1 = inv(MÎ·2)
        M2 = inv((Î”1[-1,-1] + Î») * (Î”1[-1,-1] * identity(c) - tÎ”2) + Î» * B2)

        H1 = inv(U1P - U1N) @ (expm(k * U1P) - expm(k * U1N))
        H2 = M0 @ (identity(c) - expm(k* U1N) + U1N @ H1)
        H3 = H1 + tÎ”1 @ H2
        H4 = - Î» * B1 @ H2

        H5 = inv(U1P - U1N) @ (U1P @ expm(k * U1P) - U1N @ expm(k * U1N))
        H6 = M0 @ (U1N @ expm(k * U1N) - U1N @ H5)
        H7 = H5 - tÎ”1 @ H6
        H8 = Î» * B1 @ H6

        H9 = (tÎ”1 - tÎ”2) @ M2 @ U2N + tÎ”1 @ (tÎ”1 - tÎ”2) @ M2 
        H10 = U2N - Î» * (identity(c) - B2 @ inv(tÎ”2)) @ H9
        H11 = M1 @ U2N + inv(tÎ”2) @ H9
        H12 = H10 + Î» * (B1 @ inv(tÎ”1) @ tÎ”2 - B2) @ H11
        H13 = tÎ”2 @ H11
        H14 = Î» * B1 @ inv(tÎ”1) @ tÎ”2 @ H11

        H15 = inv(H7 - H7 @ H9 - H3 @ H12 + H13)
        H16 = (H14 + H4 @ H12 - H8 + H8 @ H9) @ H15

        H17 = tÎ”2 @ M1 - Î» * H3 @ (B1 @ inv(tÎ”1) @ tÎ”2 - B2) @ M1
        H18 = Î» * B1 @ inv(tÎ”1) @ tÎ”2 @ M1 + Î» * H4 @ (B1 @ inv(tÎ”1) @ tÎ”2 - B2) @ M1
        H19 = identity(c) - U2N @ H15 @ H17
        H20 = H16 @ H17 - H18

        # Solving the final system of equations
        def hC(n):
            if (n==0):
                return hB(0) / Î»
            if (n<c-1):
                return hB(n) @ inv(Î» * (identity(n+1) - hC(n-1) @ hI(n))+ hÎ”(n) )
            if (n==c-1):
                return - U2N @ H15 @ inv(Î» * (identity(c) - hC(c-2) @ hI(c-1)) + hÎ”(c-1)  - H16)
            return -1

        def hH(n):
            if (n==c-1):
                return hC(c-1)
            if (n<c-1):
                return hH(n+1) @ hC(n)
            return -1

        bcsol = 1/(sum(vÎ·2 @ (H19 + hH(c-1) @ H20)) + sum([sum(vÎ·2 @ hH(n)) for n in range(c)]))
        Î´sol = lambda n : bcsol * vÎ·2 @ hH(n)


        # Constructing the workload function
        vf0sol = Î´sol(c-1) @ H16 - bcsol * vÎ·2 @ U2N @ H15
        vfksol = vf0sol @ H7 + Î´sol(c-1) @ H8
        vFksol = vf0sol @ H3 + Î´sol(c-1) @ H4

        ð›¼0sol = vf0sol @ tÎ”1 - Î» * Î´sol(c-1) @ B1
        ð›¼1sol = ð›¼0sol @ inv(tÎ”1) @ tÎ”2 - Î» * vFksol @ (B1 @ inv(tÎ”1) @ tÎ”2 - B2)
        ð›¼2sol = ð›¼1sol @ inv(tÎ”2) - vfksol +  Î» * vFksol @ (identity(c) - B2 @ inv(tÎ”2))

        F2solInf = bcsol * vÎ·2 @ H19 + Î´sol(c-1) @ H20
        Wpos = 1 - sum(F2solInf)

        F1sol = lambda x : (vf0sol + ð›¼0sol @ M0 @ U1N) @ inv(U1P - U1N) @ (expm(x*U1P) - expm(x*U1N)) + ð›¼0sol @ M0 @ (identity(c) - expm(x*U1N))
        F2sol = lambda x : vFksol @ expm((x-k)*U2N) + (bcsol * vÎ·2 + ð›¼1sol @ M1) @ (identity(c) - expm((x-k)*U2N)) - ð›¼2sol @ ((tÎ”1-tÎ”2) @ M2 @ expm((x-k)*U2N) - tQ1(x-k) @ (tÎ”1-tÎ”2) @ M2)
        Fsol = lambda x :  F1sol(x) if (x<k) else F2sol(x)
        Wsol = lambda x :  Wpos + sum(Fsol(x))

        # returning the workload function 
        return Wsol
    `

    pythonCode = ` 
      Î»=2; Î¼1=0.75; Î¼2=1.12; k=0.45; Ï=Î»/(2*Î¼2)
      crange = range(2,5)
      xpoints = np.linspace(start=0, stop=20*k, num=250)
      wfun = workload(2, Î», Î¼1, Î¼2, k)
      print([wfun(x) for x in xpoints])
    `

    languagePluginLoader.then(() => {
      return pyodide.loadPackage(['numpy'])
    }).then(() => {
        pyodide.runPython(pythonImports);
        pyodide.runPython(pythonDefinitions);
        pyodide.runPython(pythonWorkloadFunction);
        pyodide.runPython(pythonCode);
    })
  </script>
</body>
</html>