<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Plotting workload distribution</title>
  <!-- Font Awesome 
    <script defer src="https://use.fontawesome.com/releases/v5.14.0/js/all.js"></script>
  -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.9.1/css/bulma.min.css">
  <link rel="stylesheet" href="index.css">
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/8.1.0/math.js"></script>
  <!-- Load plotly.js into the DOM -->
  <script src='https://cdn.plot.ly/plotly-latest.min.js'></script>
</head>
<body>
  <section class="section">
    <div class="container">
      <h1 class="title">Virtual Queueing Time distribution</h1>
      <p class="subtitle">Generates the plots of the Virtual Queueing Time distributions of a special kind of queueing system.</p>
      <p>This queueing system has <b>c</b> servers and an arrival stream of customers of Poisson type with homogeneous parameter <b>&lambda;</b>.</p>
      <p>Whenever a customer arrives it is tagged as <i>customer of type <b>1</b></i> on arrival the workload is below the threshold <b>k</b>, otherwise it is tagged as <i>customer of type <b>2</b></i>.</p>
      <p>All customers have a service time exponential distributed, type 1 customers with parameter <b>&mu;<sub>1</sub></b> and type 2 customers with parameter <b>&mu;<sub>2</sub></b>.</p>
  </div>
  </section>

  <div id="tabs-with-content">
  <div class="tabs is-toggle is-large is-centered">
    <ul>
      <li class="is-active" data-tab="CDF"><a>Distribution</a></li>
      <li data-tab="PDF"><a>Density</a></li>
      <li data-tab="Mean"><a>Mean</a></li>
    </ul>
  </div>

  <section class="main-content columns is-fullheight is-active" data-content="CDF">
  
    <aside class="column is-2 is-fullheight section">
      <p class="menu-label">Parameters</p>
      <ul class="menu-list">
        <li class="control has-icons-left">
          <input class="input" type="text" name="param_c" value="3;2;4;5">  
          <span class="icon is-left">c</span>
        </li>
        <li class="control has-icons-left">
          <input class="input" type="text" name="param_lambda" value="2">  
          <span class="icon is-left">&lambda;</span>
        </li>
        <li class="control has-icons-left">
          <input class="input" type="text" name="param_mu1" value="0.75">  
          <span class="icon is-left">&mu;<sub>1</sub></span>
        </li>
        <li class="control has-icons-left">
          <input class="input" type="text" name="param_mu2" value="1.12">
          <span class="icon is-left">&mu;<sub>2</sub></span>
        </li>
        <li class="control has-icons-left">
          <input class="input" type="text" name="param_k" value="0.45">  
          <span class="icon is-left">k</span>
        </li>
        <li class="button is-link is-outlined is-fullwidth" data-ID="btn_draw" onclick="updateGraph('CDF');"/>
          Draw
        </li>
      </ul>
    </aside>
  
    <div class="container column is-10">
      <div class="section">
        
        <div class="card is-hidden1">
          <div class="card-header"><p class="card-header-title">CDF of the VQT</p></div>
          <div class="card-content">
            <div class="content" data-ID="root"></div>
          </div>
        </div>
        <br />
        
      </div>
    </div>
    
  </section>

  <section class="main-content columns is-fullheight" data-content="PDF">
  
    <aside class="column is-2 is-fullheight section">
      <p class="menu-label">Parameters</p>
      <ul class="menu-list">
        <li class="control has-icons-left">
          <input class="input" type="text" name="param_c" value="3">  
          <span class="icon is-left">c</span>
        </li>
        <li class="control has-icons-left">
          <input class="input" type="text" name="param_lambda" value="5">  
          <span class="icon is-left">&lambda;</span>
        </li>
        <li class="control has-icons-left">
          <input class="input" type="text" name="param_mu1" value="1.2;1.6;1.65;1.7;1.8">  
          <span class="icon is-left">&mu;<sub>1</sub></span>
        </li>
        <li class="control has-icons-left">
          <input class="input" type="text" name="param_mu2" value="2">
          <span class="icon is-left">&mu;<sub>2</sub></span>
        </li>
        <li class="control has-icons-left">
          <input class="input" type="text" name="param_k" value="6">  
          <span class="icon is-left">k</span>
        </li>
        <li class="button is-link is-outlined is-fullwidth" data-ID="btn_draw" onclick="updateGraph('PDF');"/>
          Draw
        </li>
      </ul>
    </aside>
  
    <div class="container column is-10">
      <div class="section">
        
        <div class="card is-hidden1">
          <div class="card-header"><p class="card-header-title">PDF of the VQT</p></div>
          <div class="card-content">
            <div class="content" data-ID="root"></div>
          </div>
        </div>
        <br />
        
      </div>
    </div>
    
  </section>

  <section class="main-content columns is-fullheight" data-content="Mean">
  
    <aside class="column is-2 is-fullheight section">
      <p class="menu-label">Parameters</p>
      <ul class="menu-list">
        <li class="control has-icons-left">
          <input class="input" type="text" name="param_c" value="2;3;4">  
          <span class="icon is-left">c</span>
        </li>
        <li class="control has-icons-left" style="display: none;">
          <input class="input" type="text" name="param_lambda" value="0.0000001">  
          <span class="icon is-left">&lambda;</span>
        </li>
        <li class="control has-icons-left">
          <input class="input" type="text" name="param_mu1" value="0.81">  
          <span class="icon is-left">&mu;<sub>1</sub></span>
        </li>
        <li class="control has-icons-left">
          <input class="input" type="text" name="param_mu2" value="0.93">
          <span class="icon is-left">&mu;<sub>2</sub></span>
        </li>
        <li class="control has-icons-left">
          <input class="input" type="text" name="param_k" value="6">  
          <span class="icon is-left">k</span>
        </li>
        <li class="control checkbox has-icons-left input">
          <input type="checkbox" name="logscale" checked="checked">
          Log scale
        </li>
        <li class="button is-link is-outlined is-fullwidth" data-ID="btn_draw" onclick="updateGraph('Mean');"/>
          Draw
        </li>
      </ul>
    </aside>
  
    <div class="container column is-10">
      <div class="section">
        
        <div class="card is-hidden1">
          <div class="card-header"><p class="card-header-title">Mean Virtual Queueing Time</p></div>
          <div class="card-content">
            <div class="content" data-ID="root"></div>
          </div>
        </div>
        <br />
        
      </div>
    </div>
    
  </section>
</div>
  
  <footer class="footer">
    <div class="content">
      <span>Open the <a href="index-pyodide.html">Pyodide</a> version.</span> 
      <span>Open the <a href="https://github.com/brdauria/VQTPlot" target="_blank">Github repository</a>.</span> 
    </div>
  </footer>
  
  <script> 
    // Utility functions
    const kδ = bool => bool ? 1 : 0
    const range = n => [...Array(n).keys()]
    const make_array = (n, f) => math.map(range(n), f)
    const make_diag = (n, f) => math.diag(math.map(range(n), f))
    const make_matrix = (n, m, f) => math.map(range(n), i => math.map(range(m), j => f(i,j)))
    const getRow = (M, i) => math.flatten(M.subset(math.index(i, math.range(0, M._size[0])))).toArray();
    const getColumn = (M, i) => math.flatten(M.subset(math.index(math.range(0, M._size[0]),i))).toArray();
    // apporxeq & chop functions
    let approxeq = (v1, v2, epsilon = 0.001) => Math.abs(v1 - v2) <= epsilon;
    let chop = (v, epsilon = 0.000001) => Math.abs(v) < epsilon ? 0 : v;
    let capitalized = name => name.charAt(0).toUpperCase() + name.slice(1)
    const null_space = M => math.multiply(math.ones(M._size[0]),math.inv(math.add(math.ones(M._size[0],M._size[0]), M)));
    const normalize = v => math.multiply(1/math.norm(v),v);
    const eigenvector = M => normalize(null_space(M.map(chop)));


    function workloadMMc(c=2, λ=1, μ2=0.55) {
      const rho = λ/(c*μ2)
      const piC = 1
      const VQTcdf = x => 1 - piC * math.exp(-c*μ2*(1-rho)*x) / (1-rho) ; 
      const VQTdf = x => piC * math.exp(-c*μ2*(1-rho)*x) * c * μ2; 
      VQTmean = piC/(c * μ2 * (1-rho) * (1-rho));

      return {"CDF": VQTcdf, "PDF": VQTdf, "Mean": VQTmean}
    }

    function workload(c=2, λ=1, μ1=0.45, μ2=0.55, k=0.1) {

      if (μ1 == μ2) return workloadMMc(c, λ, μ2)

      // Definitions
      const μ = (i, j) => i * μ1 + j * μ2;
      const Δ0 = make_diag(c, i => μ(i,c-1-i));
      const Δ1 = make_diag(c, i => μ(i+1,c-1-i));
      const Δ2 = make_diag(c,  i => μ(i,c-i));

      const μvec = n => make_array(n+1, i => μ(i,n-i));
      const hΔ = n => math.diag(μvec(n));
      const hB = n => make_matrix(n+2, n+1, (i,j) => kδ(i==j)*(n+1-i)*μ2+kδ(i==j+1)*i*μ1);
      const hI = n => make_matrix(n, n+1, (i,j) => kδ(i+1==j));

      const Q1 = x => math.expm(math.multiply(-x, Δ1))
      const Q2 = x => math.expm(math.multiply(-x, Δ2))
      const B1 = make_matrix(c, c, (i,j) => kδ(i==j)*(i+1)*μ1+kδ(i+1==j)*(c-1-i)*μ2);
      const B2 = make_matrix(c, c, (i,j) => kδ(i==j)*(c-i)*μ2+kδ(i-1==j)*i*μ1);

      const tΔ1 = math.multiply(math.inv(B1), Δ1, B1)
      const tΔ2 = math.multiply(math.inv(B2), Δ2, B2)
      const tQ1 = x => math.multiply(math.inv(B1), Q1(x), B1)
      const tQ2 = x => math.multiply(math.inv(B2), Q2(x), B2)

      // Solving homogeneous equations
      const D1 = x => math.add(
        math.multiply(x, x, math.identity(c)),
        math.multiply(-x, λ, math.identity(c)),
        math.multiply(x, tΔ1),
        math.multiply(λ, B1),
        math.multiply(-λ, tΔ1))
      const D2 = x => math.add(
        math.multiply(x, x, math.identity(c)),
        math.multiply(-x, λ, math.identity(c)),
        math.multiply(x, tΔ2),
        math.multiply(λ, B2),
        math.multiply(-λ, tΔ2))

      const θ1P = make_array(c, i => (λ-μ(i+1,c-1-i)+math.sqrt(math.square(λ-μ(i+1,c-1-i))+4*λ*μ(0,c-1-i)))/2)
      const θ1N = make_array(c, i => (λ-μ(i+1,c-1-i)-math.sqrt(math.square(λ-μ(i+1,c-1-i))+4*λ*μ(0,c-1-i)))/2)
      const θ2P = make_array(c, i => (λ-μ(i,c-i)+math.sqrt(math.square(λ-μ(i,c-i))+4*λ*μ(i,0)))/2)
      const θ2N = make_array(c, i => (λ-μ(i,c-i)-math.sqrt(math.square(λ-μ(i,c-i))+4*λ*μ(i,0)))/2)

      const ɸ1P = math.matrix(make_array(c, i => eigenvector(D1(θ1P[i]))));
      const ɸ1N = math.matrix(make_array(c, i => eigenvector(D1(θ1N[i]))));
      const ɸ2P = math.matrix(make_array(c, i => eigenvector(D2(θ2P[i]))));
      const ɸ2N = math.matrix(make_array(c, i => eigenvector(D2(θ2N[i]))));

      const U1P = math.multiply(math.inv(ɸ1P), math.diag(θ1P), ɸ1P);
      const U1N = math.multiply(math.inv(ɸ1N), math.diag(θ1N), ɸ1N);
      const U2P = math.multiply(math.inv(ɸ2P), math.diag(θ2P), ɸ2P);
      const U2N = math.multiply(math.inv(ɸ2N), math.diag(θ2N), ɸ2N);

      // Solving homogeneous equations
      const vη1 = eigenvector(D1(0));
      const Mη1 = math.add(
        math.multiply(λ, B1),
        math.multiply(-λ, tΔ1),
        math.multiply(-1, make_array(c, i => vη1)));
      const M0 = math.inv(Mη1);
      const vη2 = eigenvector(D2(0));
      const Mη2 = math.add(
        math.multiply(λ, B2),
        math.multiply(-λ, tΔ2),
        math.multiply(-1, make_array(c, i => vη2)));
      const M1 = math.inv(Mη2);
      const M2 = math.inv(math.add(
          math.multiply((c * μ1 + λ) * (c * μ1), math.identity(c)),
          math.multiply(-(c * μ1 + λ), tΔ2),
          math.multiply(λ, B2)));

      const invtΔ1 = math.inv(tΔ1);
      const invU2N = math.inv(U2N);
      const invU1PN = math.inv(math.subtract(U1P, U1N));
      const kU1P = math.expm(math.multiply(k, U1P));
      const kU1N = math.expm(math.multiply(k, U1N));
      const kU1PN = math.subtract(kU1P, kU1N);
      const kUU1PN = math.subtract(math.multiply(U1P, kU1P), math.multiply(U1N, kU1N));
      const tΔ12 = math.subtract(tΔ1, tΔ2);
      const BΔ12 = math.subtract(math.multiply(B1, math.inv(tΔ1), tΔ2), B2);

      iexp = v => v.map(x => x == 0 ? -k : 1-math.exp(k*x))
      const IkU1P = math.multiply(math.inv(ɸ1P), math.diag(iexp(θ1P)), ɸ1P);
      const IkU1N = math.multiply(math.inv(ɸ1N), math.diag(iexp(θ1N)), ɸ1N);

      const H1 = math.multiply(invU1PN, kU1PN);
      const H2 = math.multiply(M0, math.subtract(math.add(math.identity(c), math.multiply(U1N, H1)), kU1N));
      const H3 = math.add(H1, math.multiply(tΔ1, H2));
      const H4 = math.multiply(-λ, B1, H2);

      const H5 = math.multiply(invU1PN, kUU1PN);
      const H6 = math.subtract(math.multiply(M0, U1N, kU1N), math.multiply(M0, U1N, H5));
      const H7 = math.subtract(H5, math.multiply(tΔ1, H6));
      const H8 = math.multiply(λ, B1, H6);

      const H9 = math.add(math.multiply(tΔ12, M2, U2N), math.multiply(tΔ1, tΔ12, M2));
      const H10 = math.add(U2N, math.multiply(-λ, math.subtract(math.identity(c), math.multiply(B2, math.inv(tΔ2))), H9)); 
      const H11 = math.add(math.multiply(M1, U2N), math.multiply(math.inv(tΔ2), H9));
      const H12 = math.add(H10, math.multiply(λ, math.subtract(math.multiply(B1, math.inv(tΔ1), tΔ2), B2), H11));
      const H13 = math.multiply(tΔ2, H11);
      const H14 = math.multiply(λ, B1, math.inv(tΔ1), tΔ2, H11);

      const H15 = math.inv(math.add(H7, math.multiply(-1, H7, H9), math.multiply(-1, H3, H12), H13));
      const H16 = math.multiply(math.add(H14, math.multiply(H4, H12), math.multiply(-1, H8), math.multiply(H8, H9)), H15);

      const H17 = math.multiply(math.subtract(tΔ2, math.multiply(λ, H3, BΔ12)), M1);
      const H18 = math.add(math.multiply(λ, B1, math.inv(tΔ1), tΔ2, M1), math.multiply(λ, H4, BΔ12, M1));
      const H19 = math.subtract(math.identity(c), math.multiply(U2N, H15, H17));
      const H20 = math.subtract(math.multiply(H16, H17), H18);

      // Solving the final system of equations
      function hC(n) {
        if (n==0) return math.multiply(1/λ, hB(0));
        if (n<c-1) return math.multiply(hB(n), math.inv(math.add(math.multiply(λ, math.subtract(math.identity(n+1), math.multiply(hC(n-1), hI(n)))),hΔ(n))));
        if (n==c-1) return math.multiply(-1, U2N, H15, math.inv(math.add(math.multiply(λ, math.identity(c)), math.multiply(-λ, hC(c-2), hI(c-1)), math.subtract(hΔ(c-1),  H16))));
        return -1
      }

      function hH(n) {
        if (n==c-1) return hC(c-1);
        if (n<c-1) return math.multiply(hH(n+1), hC(n));
        return -1
      }

      const vη2sum = math.sum(make_array(c, n => math.sum(math.multiply(vη2, hH(n)))));
      const bcsol = 1/(math.sum(math.multiply(vη2, H19)) +math.sum(math.multiply(vη2, hH(c-1),H20)) + vη2sum)
      const δsol = n => math.multiply(bcsol, vη2, hH(n));

      // Constructing the workload function
      const vf0sol = math.subtract(math.multiply(δsol(c-1), H16), math.multiply(bcsol, vη2, U2N, H15));
      const vfksol = math.add(math.multiply(vf0sol, H7), math.multiply(δsol(c-1), H8));
      const vFksol = math.add(math.multiply(vf0sol, H3), math.multiply(δsol(c-1), H4));

      const 𝛼0sol = math.subtract(math.multiply(vf0sol, tΔ1), math.multiply(λ, δsol(c-1), B1));
      const 𝛼1sol = math.subtract(math.multiply(𝛼0sol, math.inv(tΔ1), tΔ2), math.multiply(λ, vFksol, BΔ12));
      const 𝛼2sol = math.add(math.multiply(𝛼1sol, math.inv(tΔ2)), math.multiply(-1,vfksol), math.multiply(λ, vFksol), math.multiply(-λ, vFksol, B2, math.inv(tΔ2)));

      const F2solInf = math.add(math.multiply(bcsol, vη2, H19), math.multiply(δsol(c-1), H20));
      const VQTpos = 1 - math.sum(F2solInf);

      const F1sol = x => math.add(math.multiply(math.add(vf0sol, math.multiply(𝛼0sol, M0, U1N)), invU1PN, math.subtract(math.expm(math.multiply(x,U1P)), math.expm(math.multiply(x,U1N)))), math.multiply(𝛼0sol, M0, math.subtract(math.identity(c), math.expm(math.multiply(x,U1N)))));
      const F2sol = x => math.add(
        math.multiply(vFksol, math.expm(math.multiply(x-k, U2N))),
        math.multiply(math.add(math.multiply(bcsol, vη2), math.multiply(𝛼1sol, M1)), math.subtract(math.identity(c), math.expm(math.multiply(x-k,U2N)))),
        math.multiply(-1, 𝛼2sol, tΔ12, M2, math.expm(math.multiply(x-k, U2N))),
        math.multiply(𝛼2sol, tQ1(x-k), tΔ12, M2));
      const Fsol = x => ((x < k) ? F1sol(x) : F2sol(x));
      const VQTcdf = x => VQTpos + math.sum(Fsol(x));

      const f1sol = x => math.subtract(math.multiply(math.add(vf0sol, math.multiply(𝛼0sol, M0, U1N)), invU1PN, math.subtract(math.multiply(U1P,math.expm(math.multiply(x,U1P))), math.multiply(U1N,math.expm(math.multiply(x,U1N))))), math.multiply(𝛼0sol, M0, U1N, math.expm(math.multiply(x,U1N))));
      const f2sol = x => math.subtract(
        math.multiply(math.subtract(vFksol, math.add(math.multiply(bcsol, vη2), math.multiply(𝛼1sol, M1), math.multiply(𝛼2sol, tΔ12, M2))), U2N , math.expm(math.multiply(x-k,U2N))), math.multiply(𝛼2sol, tQ1(x-k), tΔ1, tΔ12, M2));
      const fsol = x => ((x < k) ? f1sol(x) : f2sol(x));
      const VQTdf = x => math.sum(fsol(x));

      VQTmean = math.sum(math.multiply(math.add(vf0sol, math.multiply(𝛼0sol, M0, U1N)), invU1PN, math.subtract(math.multiply(k,math.expm(math.multiply(k,U1P))), IkU1P)));
      VQTmean -= math.sum(math.multiply(math.add(math.multiply(math.add(vf0sol, math.multiply(𝛼0sol, M0, U1N)), invU1PN),math.multiply(𝛼0sol, M0)),math.subtract(math.multiply(k,math.expm(math.multiply(k,U1N))), IkU1N))
        );
      VQTmean -= math.sum(math.multiply(math.subtract(vFksol, math.add(math.multiply(bcsol, vη2), math.multiply(𝛼1sol, M1), math.multiply(𝛼2sol, tΔ12, M2))), math.subtract(invU2N, math.multiply(k, math.identity(c)))));
      VQTmean -= math.sum(math.multiply(𝛼2sol, math.add(invtΔ1, math.multiply(k, math.identity(c))), tΔ12, M2));

      return {"CDF": VQTcdf, "PDF": VQTdf, "Mean": VQTmean}
    }

    var lambda, mu1, mu2, k, c;
    var validated ={'CDF':false, 'PDF':false, 'Mean':false}

    function remove_danger_light(el, bool) {
      if (bool) el.classList.remove('has-background-danger-light')
        else el.classList.add('has-background-danger-light');
      return bool
    }

    function read_param(s) {
      return s.split(";").map(parseFloat)
    }

    function assign_param(el) {
      let name = el.name.substring(6)
      let value = read_param(el.value)
      eval(`${name}=[${value}]`);
      eval(`el${capitalized(name)}=el`);
    }

    function is_correct(v,n) {
      if (typeof(n) == "undefined") n = n_curves
      res = v.length == 1 || v.length == n
      res = res && v.every(x=>x>0) 
      return res 
    }

    function get(v,n) {
      return (v.length == 1) ? v[0] : v[n]
    }

    function get_legend_entry(n) {
      res = ""
      if (c.length != 1) res += `c=${c[n]}`
      if (lambda.length != 1) {
        if (res!="") res+=", "
        res += `\u03BB=${lambda[n]}`
      }
      if (mu1.length != 1) {
        if (res!="") res+=", "
        res += `\u03BC1=${mu1[n]}`
      }
      if (mu2.length != 1) {
        if (res!="") res+=", "
        res += `\u03BC2=${mu2[n]}`
      }
      return res
    }

    function chechData(tab="CDF") {
      const section = document.querySelector(`section[data-content=${tab}]`);
      section.querySelectorAll("input[name^='param_']").forEach(assign_param);
      var result =  true;
      n_curves = Math.max(...[lambda, mu1, mu2, k, c].map(x => x.length));
      result &= remove_danger_light(elC, is_correct(c))
      result &= remove_danger_light(elLambda, is_correct(lambda))
      result &= remove_danger_light(elMu1, is_correct(mu1))
      result &= remove_danger_light(elMu2, is_correct(mu2))
      result &= remove_danger_light(elK, is_correct(k))
      
      for (var ix = 0; ix < n_curves; ix++){
        if (approxeq(get(lambda,ix),get(c,ix)*get(mu1,ix))) {
          result=false; 
          remove_danger_light(elLambda, false)
          remove_danger_light(elMu1, false)
          break
        }
        if (approxeq(get(lambda,ix),get(c,ix)*(get(mu1,ix)-get(mu2,ix)))) {
          result=false; 
          remove_danger_light(elLambda, false)
          remove_danger_light(elMu1, false)
          remove_danger_light(elMu2, false)
          break
        }
        if (get(mu2,ix)*get(c,ix)<=get(lambda,ix)) {
          result=false; 
          remove_danger_light(elLambda, false)
          remove_danger_light(elMu2, false)
          break
        }
      }
      return result;
    }

    async function updateGraph(tab) {
      if (!chechData(tab)) return false;
      const section = document.querySelector(`section[data-content=${tab}]`);
      let el = section.querySelector("li[data-ID='btn_draw']");
      el.disabled = true;
      el.innerHTML = 'computing...';
      await new Promise(r => setTimeout(r, 50));
      let xpoints, ypoints
      var layout = { font: {size: 12}};
      if (tab == "Mean") {
        let checkbox = section.querySelector("input[name='logscale']");
        if (checkbox.checked) layout.yaxis = {type: 'log', autorange: true}
      }
      else layout.shapes = k.map(ik => {return {
        type: 'line', 
        x0: ik, y0: 0,  x1: ik, yref: 'paper', y1: 1,
        line: { color: 'grey', width: 1.5, dash: 'dot'}}})
      let config = {responsive: true}
      let data = []
      for (var ix = 0; ix < n_curves; ix++){
        if (tab=="Mean") {
          xpoints = range(100).map(x=>x*0.73/100+0.135);
          ypoints = xpoints.map(x => workload(get(c,ix), x * get(c,ix) * get(mu2,ix), get(mu1,ix), get(mu2,ix), get(k,ix))["Mean"]);
        } else {
          let wfun = workload(get(c,ix), get(lambda,ix), get(mu1,ix), get(mu2,ix), get(k,ix));
          xpoints= range(250).map(x=>x*5*get(k,ix)/250);
          ypoints = xpoints.map(wfun[tab]);
        }
        var trace = {
          name: get_legend_entry(ix),
          x: xpoints,
          y: ypoints,
          type: 'scatter'
        }
        data.push(trace)
      }
      let div = section.querySelector("div[data-ID='root']");
      Plotly.newPlot(div, data, layout, config);
      el.innerHTML = "Update";
      el.disabled = false;
      validated[tab] = true;
    }

    var cmin = 2;
    var cspread = 3;
    var ready= false;
    var lambda, mu1, mu2, k, c, n_curves;
    var elLambda, elMu1, elMu2, elK, elC;

    // MANAGING TABS
    const TABS = [...document.querySelectorAll('div.tabs li')];
    const CONTENT = [...document.querySelectorAll('section.main-content')];
    const ACTIVE_CLASS = 'is-active';

    function initTabs() {
        TABS.forEach((tab) => {
          tab.addEventListener('click', (e) => {
            let selected = tab.getAttribute('data-tab');
            updateActiveTab(tab);
            updateActiveContent(selected);
          })
        })
        updateGraph('CDF')
    }

    function updateActiveTab(selected) {
      TABS.forEach((tab) => {
        if (tab && tab.classList.contains(ACTIVE_CLASS)) {
          tab.classList.remove(ACTIVE_CLASS);
        }
      });
      selected.classList.add(ACTIVE_CLASS);
    }

    function updateActiveContent(selected) {
      CONTENT.forEach((item) => {
        if (item && item.classList.contains(ACTIVE_CLASS)) {
          item.classList.remove(ACTIVE_CLASS);
        }
        let data = item.getAttribute('data-content');
        if (data === selected) {
          item.classList.add(ACTIVE_CLASS);
          if (!validated[selected]) updateGraph(selected)
        }
      });
    }

    initTabs();
  </script>
</body>
</html>